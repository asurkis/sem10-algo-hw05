\section{Задача 5}
\begin{enumerate}
    \item Найти количество подпалиндромов строки. $\O(n \log n)$.
    \item Найти максимальный подпалиндром строки. $\O(n)$.
\end{enumerate}

\subsection{Решение}
\subsubsection{Пункт (a)}
Построим в дополнение к строке $s$ развёрнутую строку $r$.
Очевидно, $r[n + 1 - i] = s[i]$.
Тогда $r[n + 1 - i; n + 1 - j] = s[i; j]$.
Совершим предподсчёт для вычисления хэшей подстрок $s$ и $r$ за $\O(1)$,
тут критично, чтобы это были именно одинаковые хэш-функции.

Пусть в $s$ есть какой-то палиндром с центром в $i$ и длины $2k+1$.
Тогда он будет повторён в $r$ с центром в $n + 1 - i$.
Очевидно, он будет также содержать $k$ меньших палиндромов с центром в $i$.

Если же есть какой-то палиндром длины $2k + 2$,
расположенный в $s[i - k - 1; i + k]$,
то он повторён в $r[n + 1 - i - k; n + 2 - i + k]$.

Тогда пройдёмся по всем индексам $i=1,\ldots,n$
и найдём наибольшие общие префиксы (за $\O(\log n)$) у:
\begin{itemize}
    \item $s[i; n]$ и $r[n + 1 - i; n]$ --- обозначим за $p(i)$
    \item $s[i; n]$ и $r[n + 2 - i; n]$ --- обозначим за $q(i)$
\end{itemize}

$p(i)$ --- половина (включая середину) максимального палиндрома нечётной длины,
$q(i)$ --- половина максимального палиндрома чётной длины.
Тогда общее количество палиндромов:
\[ \sum_{i=1}^n \Bigl( |p(i)| + |q(i)| \Bigr) \]

Если в строке вообще нет палиндромов длины хотя бы 2,
то $|p(i)| = 1$ и $|q(i)| = 0$.

Очевидно, с хэшированием алгоритм работает за $\O(n \log n)$
и находит количество палиндромов.

Искомый алгоритм найден.

\subsubsection{Пункт (b)}
Рассмотрим сначала нечётные палиндромы.
Заведём массив $d[i]$ --- количество палиндромов с центром в точке $i$.
Заведём также пару чисел $l$ и $r$ --- границы самого правого известного палиндрома.

Рассмотрим алгоритм:
\begin{algorithmic}
    \State $l \gets 0$
    \State $r \gets 0$
    \For{$i=1,\ldots,n$}
        \State $d[i] \gets 0$
    \EndFor
    \State $l \gets 0$
    \State $i' \gets 0$
    \For{$i=1,\ldots,n$}
        \If{$i \leq r$}
            \State $j \gets l + r - i$
            \Comment{Симметричная $i$ относительно центра палиндрома точка}
            \State $d[i] \gets \min(d[j]; j - l)$
            \LComment{
                Палиндромы с центром в $i$ как минимум не хуже,
                чем палиндромы с центром в $j$, не выходящие за пределы $[l; r]$}
        \EndIf
        \While{$d[i] < i \land i + d[i] \leq n \land s[i - d[i]] = s[i + d[i]]$}
            \State $d[i] \gets d[i] + 1$
        \EndWhile
        \If{$i + d[i] \geq r$}
            \State $l \gets i - d[i] + 1$
            \State $r \gets i + d[i] - 1$
        \EndIf
        \If{$d[i] \geq l$}
            \State $i' \gets i$
            \State $l \gets d[i] - 1$
        \EndIf
    \EndFor
    \State $[i' - l; i' + l]$ --- максимальный нечётный палиндром
\end{algorithmic}

Инициализация занимает $\O(n)$ времени.
Инициализация $d[i]$ в цикле --- $\O(1)$ на каждой итерации,
после этого либо палиндром с центром в $i$ вылезает за пределы $[l; r]$,
либо же $d[i]$ не увеличивается ни разу
(поскольку перевёрнутый палиндром с центром в $i$ уже был рассмотрен на позиции $j$),
что занимает $\O(1)$ времени.
$r$ может быть увеличен $\O(n)$ раз, поэтому весь проход занимает $\O(n)$ времени.

Аналогичным образом рассматриваются чётные палиндромы,
считаем, что их центры --- между символов и имеют индексы вида $k + \frac{1}{2}$,
тогда нужно делать соответствующую поправку $\pm \frac{1}{2}$.
Этот проход тоже будет занимать $\O(n)$ времени.

Искомый алгоритм найден.
