\section{Задача 4}
Даны строка $s$ длины $n$ и число $k$. Найдите в $s$ за время $\O(n)$ самую длинную подстроку,
представимую как степень  некоторой строки $x$, для которой $|x| = k$ (степенью строки
называют её конкатенацию с собой несколько раз).

\subsection{Решение}
За $\O(n)$ построим предподсчёт, позволяющий считать хэш строки за $\O(1)$.
Для каждого индекса $1,\ldots,n$ запишем, искали ли мы уже степень, начиная с этого индекса.
Очевидно, если мы уже нашли некоторую максимальную подстроку-степень,
то есть такую, которую нельзя расширить ни вправо, ни влево,
то смещение на $i \cdot k$ от её начала
даст нам более короткую степень.
Тогда алгоритм выглядит так:
\begin{algorithmic}
    \For{$i=1,\ldots,n$}
        \State $c_i \gets 1$
        \Comment{Раздаём ,,монетки`` подстрокам}
    \EndFor
    \State $i' \gets 0$
    \State $j' \gets 0$
    \For{$i=1,\ldots,n - k + 1$}
        \State $j \gets i$
        \While{$(c_j = 1) \land (j + k < n) \land (s[i ; i + k) = s[j ; j + k))$}
            \Comment{$\O(1)$ на итерацию}
            \State $c_j \gets 0$
            \Comment{Не более 1 итерации по каждому суффиксу, а всего их $n$}
            \State $j \gets j + k$
        \EndWhile
        \If{$j - i > j' - i'$}
            \State $i' \gets i$
            \State $j' \gets j$
        \EndIf
    \EndFor
    \State $s[i'; j' + k)$ --- ответ
\end{algorithmic}

Фактически, этот алгоритм проходит по всем
лево-максимальным подстрокам-степеням,
т.е. тем, которые нельзя расширить влево,
и по всем их расширениям вправо.
По каждой такой подстроке проход --- за $\O(1)$ благодаря хешированию,
и мы не рассматриваем повторно уже просмотренные суффиксы.
Тогда всего строк получается не более $n$,
и алгоритм работает за $\O(n)$.

Искомый алгоритм найден.
